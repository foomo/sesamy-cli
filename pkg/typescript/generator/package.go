package generator

import (
	"fmt"
	"go/ast"
	"go/types"
	"log/slog"
	"maps"
	"slices"
	"strings"

	"github.com/fatih/structtag"
	"github.com/foomo/gocontemplate/pkg/assume"
	"github.com/foomo/gocontemplate/pkg/contemplate"
	"github.com/foomo/sesamy-cli/pkg/code"
	"github.com/foomo/sesamy-cli/pkg/typescript"
	"github.com/stoewer/go-strcase"
)

const FallbackType = "any"

type Package struct {
	l               *slog.Logger
	Filename        string
	goctpl          *contemplate.Contemplate
	pkg             *contemplate.Package
	code            *code.File
	imports         *typescript.Imports
	pkgNameReplacer *strings.Replacer
}

// ------------------------------------------------------------------------------------------------
// ~ Constructor
// ------------------------------------------------------------------------------------------------

func NewPackage(l *slog.Logger, goctpl *contemplate.Contemplate, pkg *contemplate.Package, pkgNameReplacer *strings.Replacer) *Package {
	inst := &Package{
		l:               l,
		goctpl:          goctpl,
		pkg:             pkg,
		Filename:        pkgNameReplacer.Replace(pkg.Path()) + ".ts",
		pkgNameReplacer: pkgNameReplacer,
		code:            code.NewFile(),
		imports:         typescript.NewImports(),
	}
	return inst
}

// ------------------------------------------------------------------------------------------------
// ~ Getter
// ------------------------------------------------------------------------------------------------

func (p *Package) Code() *code.File {
	return p.code
}

// ------------------------------------------------------------------------------------------------
// ~ Public methods
// ------------------------------------------------------------------------------------------------

func (p *Package) IsSesamyEvent(expr ast.Expr) bool {
	if ident := assume.T[*ast.Ident](expr); ident != nil {
		if typeSpec := assume.T[*ast.TypeSpec](ident.Obj.Decl); typeSpec != nil {
			if indexExpr := assume.T[*ast.IndexExpr](typeSpec.Type); indexExpr != nil {
				if selectorExpr := assume.T[*ast.SelectorExpr](indexExpr.X); selectorExpr != nil {
					if xIdent := assume.T[*ast.Ident](selectorExpr.X); xIdent != nil {
						return xIdent.Name == "sesamy" && selectorExpr.Sel.Name == "Event"
					}
				}
			}
		}
	}
	return false
}

func (p *Package) Generate() error {
	// add annotations
	p.code.Annotations().Sprintf(`// Code generated by sesamy. DO NOT EDIT.`)

	var err error
	for scopeTypeName, scopeType := range p.pkg.ScopeTypes() {
		switch t := scopeType.Type().Underlying().(type) {
		case *types.Struct:
			expr := p.pkg.LookupExpr(scopeTypeName)
			if p.IsSesamyEvent(expr) {
				err = p.renderSesamyEvent(expr)
			} else {
				err = p.renderStruct(scopeType, scopeTypeName, t)
			}
			if err != nil {
				return err
			}
		case *types.Basic:
			p.renderTypeBasic(scopeTypeName, scopeType)
		default:
			p.l.Debug("ðŸ‘· unhandled type", "type", t)
		}
	}

	p.imports.Write(p.code.Head())

	return nil
}

// ------------------------------------------------------------------------------------------------
// ~ Private methods
// ------------------------------------------------------------------------------------------------

func (p *Package) renderTypeBasic(typeName string, typeObject types.Object) {
	res := map[string]string{}

	for _, object := range p.goctpl.LookupTypesByType(typeObject) {
		if objectType := assume.T[*types.Const](object); objectType != nil {
			if objectTypeNamed := assume.T[*types.Named](objectType.Type()); objectTypeNamed != nil {
				if objectTypeNamed.Obj() == typeObject {
					res[strings.TrimPrefix(object.Name(), typeName)] = objectType.Val().String()
				}
			}
		}
	}

	names := slices.AppendSeq(make([]string, 0, len(res)), maps.Keys(res))
	slices.Sort(names)

	typeValues := &strings.Builder{}
	for _, name := range names {
		typeValues.WriteString(fmt.Sprintf("\t%s = %s,\n", name, res[name]))
	}

	p.code.Body().Tprintn(`
export enum {0} {
{1}
}`,
		typeName,
		strings.TrimSuffix(typeValues.String(), "\n"),
	)
}

func (p *Package) tsASTExpr(input ast.Expr) string {
	switch t := input.(type) {
	case *ast.SelectorExpr:
		return p.tsAstType(p.pkg.Raw().TypesInfo.TypeOf(t.Sel))
	case *ast.IndexExpr:
		return fmt.Sprintf("%s<%s>", p.tsASTExpr(t.X), p.tsASTExpr(t.Index))
	case *ast.Ident:
		return t.Name
	default:
		p.l.Debug("ðŸ‘· unhandled type", "type", t)
		return FallbackType
	}
}

func (p *Package) tsAstType(input types.Type) string {
	switch t := input.(type) {
	case *types.Named:
		return p.tsTypeFromNamed(t)
	default:
		p.l.Debug("ðŸ‘· unhandled type", "type", t)
		return FallbackType
	}
}

func (p *Package) renderSesamyEvent(v ast.Expr) error {
	p.imports.Import("@foomo/sesamy").AddModule("collect")
	p.imports.Import("./github_com_foomo_sesamy_go_pkg_sesamy").AddModule("EventName")

	var typeName string
	var typeType string
	if inputIdent := assume.T[*ast.Ident](v); inputIdent != nil {
		typeName = inputIdent.Name
		if inputTypeSpec := assume.T[*ast.TypeSpec](inputIdent.Obj.Decl); inputTypeSpec != nil {
			if inputIndexExpr := assume.T[*ast.IndexExpr](inputTypeSpec.Type); inputIndexExpr != nil {
				typeType = p.tsASTExpr(inputIndexExpr.Index)
			}
		}
	}

	p.code.Body().Tprintn(`
export const {0} = (
	params: {1},
) => {
	collect({
		name: EventName.{2},
		params,
	});
};`,
		strcase.LowerCamelCase(typeName),
		typeType,
		typeName,
	)
	return nil
}

func (p *Package) renderStruct(obj types.Object, typeName string, t *types.Struct) error {
	typeFields := &strings.Builder{}

	for i := range t.NumFields() {
		tag := t.Tag(i)
		field := t.Field(i)
		name := field.Name()

		tags, err := structtag.Parse(strings.Trim(tag, "`"))
		if err != nil {
			return err
		}

		tagVal, err := tags.Get("json")
		if err != nil {
			return err
		}

		if value := tagVal.Value(); value != "" && value != "-" {
			name = tagVal.Name
		}

		if tagVal.HasOption("omitempty") {
			name += "?"
		}

		typeFields.WriteString(
			fmt.Sprintf("\t%s: %s;\n", name, p.tsType(t.Field(i).Type())),
		)
	}

	if typeFields.Len() == 0 {
		p.code.Body().Tprintn(`
export type {0} = {1};`,
			p.tsDecl(obj.Type()),
			"{}",
		)
	} else {
		p.code.Body().Tprintn(`
export interface {0} {
{1}
}`,
			p.tsDecl(obj.Type()),
			strings.TrimSuffix(typeFields.String(), "\n"),
		)
	}

	return nil
}

func (p *Package) tsDecl(v types.Type) string {
	switch t := v.(type) {
	case *types.Named:
		return p.tsDeclFromNamed(t)
	default:
		return ""
	}
}

func (p *Package) tsDeclFromNamed(v *types.Named) string {
	return p.tsDeclFromTypeName(v.Obj()) + p.tsDeclFromTypeParamList(v.TypeParams())
}

func (p *Package) tsDeclFromTypeName(v *types.TypeName) string {
	return v.Name()
}

func (p *Package) tsDeclFromTypeParamList(v *types.TypeParamList) string {
	if v == nil {
		return ""
	}
	params := make([]string, v.Len())
	for i := range v.Len() {
		params[i] = p.tsDeclFromTypeParam(v.At(i))
	}

	if len(params) > 0 {
		return "<" + strings.Join(params, ", ") + ">"
	}

	return ""
}

func (p *Package) tsDeclFromTypeParam(v *types.TypeParam) string {
	return v.Obj().Name()
}

func (p *Package) tsType(v types.Type) string {
	switch t := v.(type) {
	case *types.Pointer:
		return p.tsType(t.Elem()) + " | undefined"
	case *types.Basic:
		return p.tsTypeFromBasicInfoType(t.Info())
	case *types.Named:
		return p.tsTypeFromNamed(t)
	case *types.TypeParam:
		return p.tsTypeFromTypeName(t.Obj())
	case *types.Slice:
		return "Array<" + p.tsType(t.Elem()) + ">"
	default:
		p.l.Debug("ðŸ‘· unhandled type", "type", t)
		return FallbackType
	}
}

func (p *Package) tsTypeFromBasicInfoType(c types.BasicInfo) string {
	switch {
	case c&types.IsNumeric != 0:
		return "number"
	case c&types.IsString != 0:
		return "string"
	case c&types.IsBoolean != 0:
		return "boolean"
	default:
		p.l.Debug("ðŸ‘· unhandled type", "type", c)
		return FallbackType
	}
}

func (p *Package) tsTypeFromTypeName(t *types.TypeName) string {
	name := t.Name()
	// add package prefix is needed
	if t.Pkg().Path() != p.pkg.Path() {
		// retrieve ts package name
		tsPkg := p.pkgNameReplacer.Replace(t.Pkg().Path())
		// ensure import exists
		p.imports.Import("./" + tsPkg).SetDefault("type * as " + tsPkg)
		name = tsPkg + "." + name
	}
	return name
}

func (p *Package) tsTypeFromNamed(t *types.Named) string {
	return p.tsTypeFromTypeName(t.Obj()) // + b.tsTypeFromTypeParamList(t.TypeParams())
}

// func (p *Package) tsTypeFromTypeParamList(t *types.TypeParamList) string {
// 	if t == nil {
// 		return ""
// 	}
// 	params := make([]string, t.Len())
// 	for i := range t.Len() {
// 		params[i] = p.tsTypeFromTypeParam(t.At(i))
// 	}
//
// 	if len(params) > 0 {
// 		return "<" + strings.Join(params, ", ") + ">"
// 	}
//
// 	return ""
// }

// func (p *Package) tsTypeFromTypeParam(t *types.TypeParam) string {
// 	return p.tsType(t)
// }
