package typescript

import (
	"context"
	"fmt"
	"go/ast"
	"go/types"
	"slices"
	"strings"

	"github.com/foomo/sesamy-cli/internal"
	"github.com/pterm/pterm"
	"github.com/stoewer/go-strcase"
	"golang.org/x/exp/maps"
)

type Package struct {
	Filename        string
	code            *File
	imports         *Imports
	pkgNameReplacer *strings.Replacer
	pkg             *internal.Package
	l               *internal.Loader
}

func NewPackage(l *internal.Loader, pkg *internal.Package, pkgNameReplacer *strings.Replacer) *Package {
	inst := &Package{
		l:               l,
		pkg:             pkg,
		Filename:        pkgNameReplacer.Replace(pkg.Path()) + ".ts",
		pkgNameReplacer: pkgNameReplacer,
		code:            NewFile(),
		imports:         NewImports(),
	}
	return inst
}

func (b *Package) Code() *File {
	return b.code
}

func (b *Package) IsSesamyEvent(expr ast.Expr) bool {
	if ident := internal.TC[*ast.Ident](expr); ident != nil {
		if typeSpec := internal.TC[*ast.TypeSpec](ident.Obj.Decl); typeSpec != nil {
			if indexExpr := internal.TC[*ast.IndexExpr](typeSpec.Type); indexExpr != nil {
				if selectorExpr := internal.TC[*ast.SelectorExpr](indexExpr.X); selectorExpr != nil {
					if xIdent := internal.TC[*ast.Ident](selectorExpr.X); xIdent != nil {
						return xIdent.Name == "sesamy" && selectorExpr.Sel.Name == "Event"
					}
				}
			}
		}
	}
	return false
}

func (b *Package) Build(ctx context.Context) error {
	// add annotations
	b.code.Annotations().Sprintf(`// Code generated by sesamy. DO NOT EDIT.`)

	var err error
	for scopeTypeName, scopeType := range b.pkg.ScopeTypes() {
		switch t := scopeType.Type().Underlying().(type) {
		case *types.Struct:
			if b.IsSesamyEvent(b.pkg.LookupExpr(scopeTypeName)) {
				err = b.renderSesamyEvent(scopeTypeName, t)
			} else {
				err = b.renderStruct(scopeType, scopeTypeName, t)
			}
			if err != nil {
				return err
			}
		case *types.Basic:
			b.renderTypeBasic(scopeTypeName, scopeType)
		default:
			pterm.Debug.Println("unhandled type", t)
		}
	}

	b.imports.Write(b.code.Head())

	return nil
}

func (b *Package) renderTypeBasic(typeName string, typeObject types.Object) {
	res := map[string]string{}

	for _, object := range b.l.LookupTypesByType(typeObject) {
		if objectType := internal.TC[*types.Const](object); objectType != nil {
			if objectTypeNamed := internal.TC[*types.Named](objectType.Type()); objectTypeNamed != nil {
				if objectTypeNamed.Obj() == typeObject {
					res[strings.TrimPrefix(object.Name(), typeName)] = objectType.Val().String()
				}
			}
		}
	}

	names := maps.Keys(res)
	slices.Sort(names)

	typeValues := &strings.Builder{}
	for _, name := range names {
		typeValues.WriteString(fmt.Sprintf("\t%s = %s,\n", name, res[name]))
	}

	b.code.Body().Tprintn(`
export enum {0} {
{1}
}`,
		typeName,
		strings.TrimSuffix(typeValues.String(), "\n"),
	)
}

func (b *Package) renderSesamyEvent(typeName string, t *types.Struct) error {
	b.imports.Import("@foomo/sesamy").AddModule("collect")
	b.imports.Import("./github_com_foomo_sesamy_go").AddModule("EventName")

	b.code.Body().Tprintn(`
export const {0} = (
	params: {1},
) => {
	collect({
		name: EventName.{2},
		params,
	});
}`,
		strcase.LowerCamelCase(typeName),
		b.tsType(t.Field(1).Type()),
		typeName,
	)
	return nil
}

func (b *Package) renderStruct(obj types.Object, typeName string, t *types.Struct) error {
	typeFields := &strings.Builder{}

	for i := range t.NumFields() {
		tag, err := internal.ParseTag(t.Tag(i))
		if err != nil {
			return err
		}
		if tag != "" {
			typeFields.WriteString(
				fmt.Sprintf("\t%s: %s;\n", tag, b.tsType(t.Field(i).Type())),
			)
		}
	}

	if typeFields.Len() == 0 {
		b.code.Body().Tprintn(`
export type {0} = {1}`,
			b.tsDecl(obj.Type()),
			"{}",
		)
	} else {
		b.code.Body().Tprintn(`
export interface {0} {
{1}
}`,
			b.tsDecl(obj.Type()),
			strings.TrimSuffix(typeFields.String(), "\n"),
		)
	}

	return nil
}

func (b *Package) tsDecl(t types.Type) string {
	switch t := t.(type) {
	case *types.Named:
		return b.tsDeclFromNamed(t)
	default:
		return ""
	}
}

func (b *Package) tsDeclFromNamed(t *types.Named) string {
	return b.tsDeclFromTypeName(t.Obj()) + b.tsDeclFromTypeParamList(t.TypeParams())
}

func (b *Package) tsDeclFromTypeName(t *types.TypeName) string {
	return t.Name()
}

func (b *Package) tsDeclFromTypeParamList(t *types.TypeParamList) string {
	if t == nil {
		return ""
	}
	params := make([]string, t.Len())
	for i := range t.Len() {
		params[i] = b.tsDeclFromTypeParam(t.At(i))
	}

	if len(params) > 0 {
		return "<" + strings.Join(params, ", ") + ">"
	}

	return ""
}

func (b *Package) tsDeclFromTypeParam(t *types.TypeParam) string {
	return t.Obj().Name()
}

func (b *Package) tsType(value types.Type) string {
	switch t := value.(type) {
	case *types.Basic:
		return b.tsTypeFromBasicInfoType(t.Info())
	case *types.Named:
		return b.tsTypeFromNamed(t)
	case *types.TypeParam:
		return b.tsTypeFromTypeName(t.Obj())
	case *types.Slice:
		return "Array<" + b.tsType(t.Elem()) + ">"
	default:
		return "any"
	}
}

func (b *Package) tsTypeFromBasicInfoType(c types.BasicInfo) string {
	switch {
	case c&types.IsNumeric != 0:
		return "number"
	case c&types.IsString != 0:
		return "string"
	case c&types.IsBoolean != 0:
		return "boolean"
	default:
		return "any"
	}
}

func (b *Package) tsTypeFromTypeName(t *types.TypeName) string {
	name := t.Name()
	// add package prefix is needed
	if t.Pkg().Path() != b.pkg.Path() {
		pkgName := b.pkgNameReplacer.Replace(t.Pkg().Path())
		// ensure import exists
		b.imports.Import("./" + pkgName).def = "type * as " + pkgName
		name = pkgName + "." + name
	}
	return name
}
func (b *Package) tsTypeFromNamed(t *types.Named) string {
	return b.tsTypeFromTypeName(t.Obj()) + b.tsTypeFromTypeParamList(t.TypeParams())
}

func (b *Package) tsTypeFromTypeParamList(t *types.TypeParamList) string {
	if t == nil {
		return ""
	}
	params := make([]string, t.Len())
	for i := range t.Len() {
		params[i] = b.tsTypeFromTypeParam(t.At(i))
	}

	if len(params) > 0 {
		return "<" + strings.Join(params, ", ") + ">"
	}

	return ""
}

func (b *Package) tsTypeFromTypeParam(t *types.TypeParam) string {
	return b.tsType(t)
}
